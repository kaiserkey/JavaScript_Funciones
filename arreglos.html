<!DOCTYPE html>
<html lang="es-ES">
    <head>
        <title>Arreglos</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
    </head>
    <body>
        <h1>Arreglos JavaScript</h1>

        <div id="main">
            <ul>
            <ol type="1">
                <li>...</li>
                <li>...</li>
                <li>...</li>
                <li>...</li>
                <li>...</li>
                <li>...</li>
                <li>...</li>
                <li>...</li>
                <li>...</li>
                <li>...</li>
            </ol>
            </ul> 
        </div>

        <script>
            /* 
                En programaciÃ³n, un arreglo es una colecciÃ³n de elementos o cosas. 
                Los arreglos guardan datos como elementos y los regresan cuando los necesitas.
                Un par de corchetes [] representa un arreglo en JavaScript. Todos los elementos 
                en un arreglo estÃ¡n separados por una comma ",".
                En JavaScript, los arreglos pueden ser una colecciÃ³n de elementos de cualquier tipo. 
                Esto significa que tÃº puedes crear un arreglo  con elementos de tipo Cadena, 
                Boolean, NÃºmero, Objetos, e incluso otros Arreglos.

            */

            const mixedTypedArray = [100, true, 'text', {}, [1,2]];

            /* 
                La posiciÃ³n de un elemento en el arreglo es conocido como indice. 
                En JavaScript, el indice del arreglo empieza con 0, e incrementa uno a uno con cada elemento.
                El nÃºmero de elementos en el arreglo determina su longitud.
                Curiosamente, los arreglos de JavaScript no tienen longitud fija. TÃº puedes cambiar la longitud 
                en cualquier momento asignando un valor numÃ©rico positivo. 
                
                Puedes crear un arreglo de diferentes formas en JavaScript. La forma mÃ¡s sencilla es asignar 
                un valor de arreglo a una variable.
            */
            const salad = ['ğŸ…', 'ğŸ„', 'ğŸ¥¦', 'ğŸ¥’', 'ğŸŒ½', 'ğŸ¥•', 'ğŸ¥‘'];
            /* 
                Puedes acceder y traer elementos de un arreglo usando su indice, para esto necesitas usar la sintaxis 
                de los corchetes para acceder a los elementos del arreglo.

                const element = array[index];

                SegÃºn el caso, debes escoger acceder a los elementos del arreglo uno por uno o en un bucle.

            */
            
            salad[0]; // 'ğŸ…'
            salad[2]; // 'ğŸ¥¦'
            salad[5]; // 'ğŸ¥•'

            const len = salad.length;
            salad[len - 1]; // 'ğŸ¥‘'
            salad[len - 3]; // 'ğŸŒ½'

            for(let i=0; i<salad.length; i++) {
                console.log(`Index ${i} -> ${salad[i]}`);
            }

            /* 
                El mÃ©todo push() se utiliza para aÃ±adir un elemento en el arreglo. El mÃ©todo push() aÃ±ade un 
                elemento  al final del arreglo.
                Si quieres aÃ±adir un elemento al inicio del arreglo, vas a necesitar  usar el mÃ©todo unshift().
            */

            salad.push('ğŸ¥œ'); // ["ğŸ…", "ğŸ„", "ğŸ¥¦", "ğŸ¥’", "ğŸŒ½", "ğŸ¥•", "ğŸ¥‘", "ğŸ¥œ"]
            salad.unshift('ğŸ¥œ'); // ["ğŸ¥œ", "ğŸ…", "ğŸ„", "ğŸ¥¦", "ğŸ¥’", "ğŸŒ½", "ğŸ¥•", "ğŸ¥‘"]

            /* 
                La manera mÃ¡s sencilla de eliminar un solo elemento del arreglo es usando el mÃ©todo pop(). Cada vez 
                que llamas el mÃ©todo pop(), este elimina un elemento al final del arreglo. Entonces este regresa 
                el elemento eliminado  y cambia el arreglo original.
                El mÃ©todo shift() sirve para eliminar un elemento desde el principio del arreglo. Como el mÃ©todo pop(),  
                shift() regresa el elemento eliminado y cambia el arreglo original.
            */

            salad.pop(); // ğŸ¥œ
            salad.shift(); // ğŸ¥œ

            /* 
                Es posible copiar y clonar un arreglo a un nuevo arreglo usando el metodo slice(). El mÃ©todo slice() no 
                cambia el arreglo original. En cambio crea una nueva copia superficial del arreglo original.
            */
            const saladCopy = salad.slice();
            console.log(saladCopy); // ['ğŸ…', 'ğŸ„', 'ğŸ¥¦', 'ğŸ¥’', 'ğŸŒ½', 'ğŸ¥•', 'ğŸ¥‘']
            salad === saladCopy; // returns false

            /* 
                Puedes determinar si un valor es un arreglo usando el mÃ©todo Array.isArray(value). Este mÃ©todo regresa 
                verdadero si el valor que pasa es un arreglo
            */

            Array.isArray(['ğŸ…', 'ğŸ„', 'ğŸ¥¦', 'ğŸ¥’', 'ğŸŒ½', 'ğŸ¥•', 'ğŸ¥‘']); // returns true
            Array.isArray('ğŸ…'); // returns false
            Array.isArray({ 'tomate': 'ğŸ…'}); // returns false
            Array.isArray([]); // returns true

            /* 
                Con ECMAScript 6 (ES6), tenemos una nueva sintaxis para extraer mÃºltiples propiedades de un arreglo y 
                asignarlas a variables de una sola vez. Es Ãºtil para ayudar a mantener tu cÃ³digo limpio y conciso. 
                Esta nueva sintaxis es llamada desestructuraciÃ³n.

            */

            let [tomate, hongo, zanahoria] = ['ğŸ…', 'ğŸ„', 'ğŸ¥•'];
            console.log(tomate, hongo, zanahoria); // Output, ğŸ… ğŸ„ ğŸ¥•

            /* 
                Puedes asignar un valor por defecto usando desestructuraciÃ³n cuando no hay valor o es undefined para 
                el elemento arreglo
            */

            let [pepino , maiz = 'ğŸŒ½'] = ['ğŸ¥’'];
            console.log(pepino); // 'ğŸ¥’'
            console.log(maiz); // 'ğŸŒ½'

            /* 
                Puedes saltar un elemento de un arreglo a un variable. Por ejemplo, puedes no estar interesado en 
                todos los elementos de un arreglo. En este caso, saltarse un valor es Ãºtil.
            */

            let [lechuga, , palta] = ['ğŸ¥¦', 'ğŸ„', 'ğŸ¥‘'];
            console.log(lechuga); // 'ğŸ¥¦'
            console.log(palta); // 'ğŸ¥‘'

            /* 
                En JavaScript, los arreglos se pueden tener arreglos anidados. Esto significa que un 
                arreglo puede tener otro arreglo como elemento. 
             */
            let fruits = ['ğŸˆ', 'ğŸ', 'ğŸŒ', 'ğŸ‰', ['ğŸ…', 'ğŸ„', 'ğŸ¥•']];
            const veg = fruits[4]; // returns the array ['ğŸ…', 'ğŸ„', 'ğŸ¥•']
            const zan = veg[2]; // returns 'ğŸ¥•'
            fruits[4][2]; // returns 'ğŸ¥•'

            let [,,,,[,,zanahorias]] = ['ğŸˆ', 'ğŸ', 'ğŸŒ', 'ğŸ‰', ['ğŸ…', 'ğŸ„', 'ğŸ¥•']];

            /* 
                Desde ES6, podemos usar el ... (si, tres puntos consecutivos) como sintaxis spread  y 
                el resto de los parÃ¡metros en la desestructuraciÃ³n de arreglo.

                Por el resto del parÃ¡metro, el  ... aparece en el lado izquierdo de desestructuraciÃ³n.
                Para la sintaxis spread, el ... aparece en el lado derecho de la desestructuraciÃ³n.

                Podemos organizar los elementos de la izquierda de un arreglo en un nuevo arreglo. 
                El resto de los parÃ¡metros deben ser la Ãºltima variable en la sintaxis de desestructuraciÃ³n.
                En el ejemplo de abajo, tenemos organizados los dos primeros elementos de un arreglo a 
                las variables tomate y hongo. El resto de los elementos son organizados a la variable 
                rest  usando el ... La variable rest es un nuevo arreglo conteniendo los elementos sobrantes.
            */

            const [tomates, hongos, ...rest] = ['ğŸ…', 'ğŸ„', 'ğŸ¥¦', 'ğŸ¥’', 'ğŸŒ½', 'ğŸ¥•', 'ğŸ¥‘'];

            console.log(tomates); // 'ğŸ…'
            console.log(hongos); // 'ğŸ„'
            console.log(rest); // ["ğŸ¥¦", "ğŸ¥’", "ğŸŒ½", "ğŸ¥•", "ğŸ¥‘"]

            /* 
                Con el operador spread, podemos crear un clon/copia del arreglo existente
            */

            const ensalada = ['ğŸ…', 'ğŸ„', 'ğŸ¥¦', 'ğŸ¥’', 'ğŸŒ½', 'ğŸ¥•', 'ğŸ¥‘'];

            const ensaladaCloned = [...ensalada];
            console.log(ensaladaCloned); // ["ğŸ…", "ğŸ„", "ğŸ¥¦", "ğŸ¥’", "ğŸŒ½", "ğŸ¥•", "ğŸ¥‘"]

            ensalada === ensaladaCloned // false

            /* 
                Podemos cambiar el valor de dos variables fÃ¡cilmente usando la sintaxis de desestructuraciÃ³n de arreglo.
            */

            let primero = 'ğŸ˜”';
            let segundo = 'ğŸ™‚';
            [primero, segundo] = [segundo, primero];

            console.log(primero);  // 'ğŸ™‚'
            console.log(segundo); // 'ğŸ˜”'

            /* 
                Podemos combinar dos arreglos y crear un nuevo arreglo con todos los elementos de ambos arreglos.
             */

            const emoticon = ['ğŸ™‚', 'ğŸ˜”'];
            const veggies = ['ğŸ¥¦', 'ğŸ¥’', 'ğŸŒ½', 'ğŸ¥•'];
            const emotionalVeggies = [...emoticon, ...veggies];
            console.log(emotionalVeggies); // ["ğŸ™‚", "ğŸ˜”", "ğŸ¥¦", "ğŸ¥’", "ğŸŒ½", "ğŸ¥•"]

            /* 
                El mÃ©todo concat() combina uno o mÃ¡s arreglos y regresa un arreglo combinado. Es un mÃ©todo inmutable. 
                Esto significa que no cambia(muta) un arreglo existente.
            */

            const first = [1, 2, 3];
            const second = [4, 5, 6];

            const merged = first.concat(second);

            console.log(merged); // [1, 2, 3, 4, 5, 6]
            console.log(first); // [1, 2, 3]
            console.log(second); // [4, 5, 6]

            /* 
                Usando el mÃ©todo concat() podemos combinar mÃ¡s de dos arreglos. 
                Podemos combinar cualquier nÃºmero de arreglos con esta sintaxis:

                array.concat(arr1, arr2,..,..,..,arrN);

                El mÃ©todo join() junta todos los elementos de un arreglo usando un separador  y regresa una cadena. 
                El separador por defecto usado para juntar  es comma (,)

                Invocando el mÃ©todo join() en un arreglo vacÃ­o regresa una cadena vacÃ­a:

                [].join() // returns ""
             */
            const emotions = ['ğŸ™‚', 'ğŸ˜', 'ğŸ™„', 'ğŸ˜Ÿ'];

            const joined = emotions.join(" - ");
            console.log(joined); // "ğŸ™‚,ğŸ˜,ğŸ™„,ğŸ˜Ÿ"
            /* 
                El mÃ©todo fill() llena un arreglo con un valor estÃ¡tico. Puedes cambiar todos los elementos 
                a valores estÃ¡ticos o cambiar algunos pocos elementos seleccionados. 
                Nota el mÃ©todo fill() cambia el arreglo original.
            */

            const colors = ['red', 'blue', 'green'];

            colors.fill('pink', 1, 3); // ["red", "pink", "pink"]

            /* 
                Se puede determinar la presencia de un elemento en un arreglo usando el mÃ©todo includes(). 
                Si un elemento es encontrado, el mÃ©todo regresa true, y de otra forma false.
             */

            const names = ['tom', 'alex', 'bob', 'john'];
            names.includes('tom'); // returns true
            names.includes('july'); // returns false
            /* 
                Puedes obtener el Ã­ndice de un elemento del arreglo usando el mÃ©todo  indexOf(). EL cual devuelve 
                el Ã­ndice de la primera apariciÃ³n de un elemento en el arreglo que coincida. Si un elemento no 
                se encuentra, el  mÃ©todo indexOf() regresa -1.
             */

            const nombres = ['tom', 'alex', 'bob', 'john'];
            nombres.indexOf('alex'); // returns 1
            nombres.indexOf('rob'); // returns -1

            /* 
                Hay otro mÃ©todo lastIndexOf() esto ayuda a encontrar el Ã­ndice de la Ãºltima apariciÃ³n de un elemento en un arreglo. 
                Como indexOf(), lastIndexOf() tambiÃ©n regresa -1 cuando el elemento no es encontrado.
            */
            nombres.indexOf('tom'); // returns 0
            nombres.lastIndexOf('tom'); // returns 3
            /* 
                El mÃ©todo reverse() reserva la posiciÃ³n del elemento en un arreglo entonces el Ãºltimo elemento va en 
                la primera posiciÃ³n y la primera en la Ãºltima. El mÃ©todo reverse() modifica el arreglo original.
             */
             nombres.reverse(); // returns ["bob", "alex", "tom"]

            /* 
                El mÃ©todo sort() convierte a un String cada elemento de un arreglo y luego los ordena. El orden de clasificaciÃ³n 
                predeterminado es ascendente. El mÃ©todo sort () cambia la matriz original.
                El mÃ©todo sort () acepta una funciÃ³n de comparaciÃ³n opcional como argumento. Puedes escribir una 
                funciÃ³n de comparaciÃ³n y pasar al mÃ©todo sort () para anular el comportamiento de clasificaciÃ³n 
                predeterminado
            */
            nombres.sort(); // returns ['alex', 'bob', 'john', 'tom']
            
            const numeros = [23, 5, 100, 56, 9, 13, 37, 10, 1]

            function ascendingComp(a, b){
                return (a-b);
            }
            numeros.sort(ascendingComp); // retruns [1, 5, 9, 10, 13, 23, 37, 56, 100]

            /* 

            TambiÃ©n podemos codificarlo como,

            numeros.sort(function(a, b) {
            return (a-b);
            });

            O,  con la funcion arrow,

            numeros.sort((a, b) => (a-b));

            */
            numeros.sort((a, b) => (b-a)); // Para el orden descendente

            /* 
                El mÃ©todo splice() ayuda a aÃ±adir, actualizar, y remover elementos de un arreglo. 
                El propÃ³sito principal del mÃ©todo splice() es eliminar elementos de un arreglo. 
                Regresa un arreglo con los elementos borrados y modifica el arreglo original. 
                Pero puedes aÃ±adir y remplazar elementos usÃ¡ndolo.

                Para aÃ±adir un elemento usando el mÃ©todo splice(), necesitamos pasar la posiciÃ³n donde queremos 
                aÃ±adir el nuevo elemento,  cuantos elementos se van a borrar, en este caso cero, y por
                ultimo el elemento que vamos a aÃ±adir.
            */

            const nombres2 = ['tom', 'alex', 'bob'];

            nombres2.splice(1, 0, 'zack');

            console.log(nombres2); // ["tom", "zack", "alex", "bob"]

            /* 
                Aqui estamos eliminando un elemento del indice 2 (el tercer elemento) y aÃ±adiendo un nuevo elemento, 
                zack. El  mÃ©todo splice() regresa un arreglo con el elemento eliminado, bob.
             */

            const nombres3 = ['tom', 'alex', 'bob'];

            const deleted = nombres3.splice(2, 1, 'zack');

            console.log(deleted); // ["bob"]
            console.log(nombres3); // ["tom", "alex", "zack"]
            /* 
                document.getElementsByTagName('li').forEach(() => {
                    // Do something here..
                })
                Esto nos da un error!!

                Â¿Pero por quÃ©? Por quÃ© la el HTMLCollection no es un arreglo. Es un objeto Array. 
                Entonces tu no puedes iterar sobre Ã©l usando forEach.

                Para esto usamos el mÃ©todo Array.from() el cual convierte el objeto tipo arreglo a un arreglo
                para que asÃ­ podamos realizar todas las operaciones de arreglo en el.
             */

            const collection = Array.from(document.getElementsByTagName('li'))
            
            console.log(collection); // => [li, li, li, li, li, li, li, li, li, li]

            /* 
                El mÃ©todo Array.of() crea un nuevo arreglo usando cualquier nÃºmero de elementos de cualquier tipo.
             */

            Array.of(2, false, 'test', {'name': 'Alex'}, [1,2])

            /* 
                Iteracion de arreglos
            */

            let students = [
            {
                'id': 001,
                'f_nombre': 'Alex',
                'l_nombre': 'B',
                'genero': 'M',
                'casado': false,
                'edad': 22,
                'paga': 250,  
                'cursos': ['JavaScript', 'React']
            },
            {
                'id': 002,
                'f_nombre': 'Ibrahim',
                'l_nombre': 'M',
                'genero': 'M',
                'casado': true,
                'edad': 32,
                'paga': 150,  
                'cursos': ['JavaScript', 'PWA']
            },
            {
                'id': 003,
                'f_nombre': 'Rubi',
                'l_nombre': 'S',
                'genero': 'F',
                'casado': false,
                'edad': 27,
                'paga': 350,  
                'cursos': ['Blogging', 'React', 'UX']
            },
            {
                'id': 004,
                'f_nombre': 'Zack',
                'l_nombre': 'F',
                'genero': 'M',
                'casado': true,
                'edad': 36,
                'paga': 250,  
                'cursos': ['Git', 'React', 'Branding']
            } 
            ];

            /* 
                filter() este mÃ©todo crea un nuevo arreglo con todos los elementos que satisfagan la condiciÃ³n 
                mencionada en la funciÃ³n. Vamos a encontrar el estudiante que es femenino. Entonces la condiciÃ³n 
                de filtro deberÃ­a ser que el genero sea igual a 'F'.
             */

            const femaleStudents = students.filter((element, index) => {
                return element.genero === 'F';
            })

            console.log(femaleStudents);

            /* 
                El mÃ©todo map()  crea un nuevo arreglo iterando a travÃ©s de los elementos y aplicando la lÃ³gica 
                que proveemos en la funciÃ³n como argumento. Vamos a crear un nuevo arreglo de los nombres completos 
                de todos los estudiantes en el arreglo de students.
            */

            const fullNames = students.map((element, index) => {
                return (fullName = element.f_nombre + ' ' + element.l_nombre)
            });

            console.log(fullNames);

            /* 
                El mÃ©todo reduce() aplica la funciÃ³n reducer de cada elemento del arreglo y regresa el resultado. 
                Vamos a aplicar la funciÃ³n reduce() en el arreglo students para calcular la cantidad total a 
                pagar por todos los estudiantes.
             */

            const total = students.reduce(
            (accumulator, student, currentIndex, array) => {
                accumulator = accumulator + student.paga;
                return (accumulator);
            }, 0);

            console.log(total); // 1000

            /* 
                Iniciamos con el  accumulator con  0.
                Aplicamos el mÃ©todo reduce en cada uno de los objetos student.  
                Accedemos la propiedad paga y la aÃ±adimos al accumulator.
                Finalmente regresaremos el accumulator.
             */

            /* 
                El mÃ©todo some() regresa un valor booleano (verdadero/falso) basado en que si al menos 
                en un elemento del arreglo la condiciÃ³n en la funciÃ³n se cumple. A ver si ahÃ­ hay 
                algÃºn estudiante menor de 30 aÃ±os de edad.
            */

            let hasStudentBelow30 = students.some((element, index) => {
                return element.edad < 30;
            });

            console.log(hasStudentBelow30); // true

            /* 
                Usando el metodo some(), tenemos que ver si hay algÃºn estudiante debajo de la edad de 30 aÃ±os. 
                Vamos a encontrar que estudiante es.
                Para hacer eso, usaremos el mÃ©todo find(). Este regresa el primer elemento encontrado del 
                arreglo que satisface la condiciÃ³n de la funciÃ³n.
                Los arreglos tienen otro metodo relacionado, findIndex(), eso regresa el Ã­ndice del elemento que 
                encontramos usando el mÃ©todo find(). Si no hay elementos que cumplan la condiciÃ³n el findIndex() 
                regresa -1.

             */

            const estudiante = students.find((element, index) => {
                return element.edad < 30;
            });

            console.log(estudiante);

            /* 
                El mÃ©todo every() detecta si cada  elemento del arreglo satisface la condiciÃ³n pasada en la funciÃ³n. 
                Vamos a encontrar si todos los estudiantes que se han suscrito al menos dos cursos.
             */

            const atLeastTwoCourses = students.every((elements, index) => {
                return elements.cursos.length >= 2;
            });

            console.log(atLeastTwoCourses); // true

            /* 
                Con la inclusiÃ³n del mÃ©todo at(), tÃº podrÃ¡s acceder a los elementos usando ambos Ã­ndices
                positivo y negativo con un solo mÃ©todo.
             */


            const junkFoodILove = ['ğŸ¥–', 'ğŸ”', 'ğŸŸ', 'ğŸ•', 'ğŸŒ­', 'ğŸ¥ª', 'ğŸŒ®', 'ğŸ¿'];

            junkFoodILove.at(0); // ğŸ¥–
            junkFoodILove.at(3); // ğŸ•
            junkFoodILove.at(-1); // ğŸ¿
            junkFoodILove.at(-5); // ğŸ•
            junkFoodILove.at(-8); // ğŸ¥–
            junkFoodILove.at(10); // undefined
        </script>
    </body>
</html>